<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Situation Monitor</title>
  <style>
    :root {
      --bg: #f4f7fb;
      --surface: #ffffff;
      --surface-2: #edf2f8;
      --text: #0f1d2f;
      --text-muted: #5d6b80;
      --accent: #2b7fff;
      --accent-soft: #dce9ff;
      --border: #d2dbea;
      --danger: #e53935;
      --success: #25a55a;
      --warning: #b06a00;
      --shadow: 0 8px 24px rgba(15, 29, 47, 0.08);
      --focus: 2px solid #ffb74d;
    }

    [data-theme="dark"] {
      --bg: #0e1420;
      --surface: #172235;
      --surface-2: #1c2a40;
      --text: #f1f6ff;
      --text-muted: #9eb0cc;
      --accent: #66a6ff;
      --accent-soft: #223755;
      --border: #324968;
      --danger: #ff7c7c;
      --success: #66d694;
      --warning: #f7c96f;
      --shadow: 0 12px 28px rgba(0, 0, 0, 0.35);
      --focus: 2px solid #ffd180;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Segoe UI", Inter, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.4;
    }

    .container {
      width: min(1200px, calc(100% - 2rem));
      margin: 0 auto;
      padding: 1rem 0 2rem;
    }

    header {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 1rem;
      align-items: center;
      margin-bottom: 1rem;
    }

    h1 {
      margin: 0;
      font-size: clamp(1.2rem, 1.6vw, 1.75rem);
    }

    .top-controls {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-end;
    }

    .status-pill {
      border: 1px solid var(--border);
      background: var(--surface);
      padding: 0.4rem 0.65rem;
      border-radius: 999px;
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .status-pill.healthy { color: var(--success); border-color: color-mix(in srgb, var(--success) 45%, var(--border)); }
    .status-pill.degraded { color: var(--warning); border-color: color-mix(in srgb, var(--warning) 45%, var(--border)); }

    .input, select, button, input[type="number"], input[type="text"] {
      font: inherit;
      color: var(--text);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      padding: 0.5rem 0.65rem;
    }

    button {
      cursor: pointer;
      background: var(--accent-soft);
      border-color: color-mix(in srgb, var(--accent) 35%, var(--border));
    }

    button:hover { filter: brightness(1.04); }
    button.secondary { background: var(--surface); }
    button.danger { background: color-mix(in srgb, var(--danger) 15%, var(--surface)); border-color: color-mix(in srgb, var(--danger) 55%, var(--border)); }
    a.link-btn {
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      padding: 0.4rem 0.65rem;
      text-decoration: none;
      color: var(--text);
      background: var(--surface);
    }

    :focus-visible {
      outline: var(--focus);
      outline-offset: 2px;
    }

    .tabs {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-bottom: 1rem;
    }

    .tab-btn[aria-selected="true"] {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    section.panel {
      display: none;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 0.8rem;
      padding: 1rem;
      box-shadow: var(--shadow);
    }

    section.panel.active { display: block; }

    .cards {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 0.8rem;
    }

    .card {
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      padding: 0.8rem;
      background: var(--surface-2);
      display: grid;
      gap: 0.35rem;
    }

    .card .name {
      font-weight: 600;
      display: flex;
      justify-content: space-between;
      gap: 0.5rem;
    }

    .price {
      font-size: 1.2rem;
      font-weight: 700;
    }

    .up { color: var(--success); }
    .down { color: var(--danger); }

    .subtle { color: var(--text-muted); font-size: 0.88rem; }

    .inline-row {
      display: flex;
      gap: 0.6rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1rem;
    }

    ul.clean {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 0.45rem;
    }

    li.item {
      border: 1px solid var(--border);
      border-radius: 0.6rem;
      padding: 0.55rem 0.65rem;
      background: var(--surface-2);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
    }

    .toasts {
      position: fixed;
      right: 1rem;
      bottom: 1rem;
      width: min(380px, calc(100% - 2rem));
      display: grid;
      gap: 0.5rem;
      z-index: 1000;
    }

    .toast {
      border: 1px solid var(--border);
      border-left: 4px solid var(--accent);
      background: var(--surface);
      border-radius: 0.65rem;
      padding: 0.6rem 0.7rem;
      box-shadow: var(--shadow);
      display: flex;
      justify-content: space-between;
      gap: 0.75rem;
      align-items: flex-start;
    }

    .diagnostics {
      font-family: Consolas, "Courier New", monospace;
      font-size: 0.85rem;
      background: var(--surface-2);
      border: 1px dashed var(--border);
      border-radius: 0.7rem;
      padding: 0.75rem;
      white-space: pre-wrap;
    }

    .table-wrap { overflow-x: auto; }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }
    th, td {
      border-bottom: 1px solid var(--border);
      text-align: left;
      padding: 0.45rem;
    }

    .hint { font-size: 0.82rem; color: var(--text-muted); }
    .muted { color: var(--text-muted); }

    @media (max-width: 720px) {
      header { grid-template-columns: 1fr; }
      .top-controls { justify-content: flex-start; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>Situation Monitor</h1>
        <div class="hint">Monitor crypto conditions, trigger local alerts, and persist everything offline-friendly.</div>
      </div>
      <div class="top-controls">
        <label>
          <span class="muted">Search</span>
          <input id="searchInput" type="text" placeholder="Filter by coin id/name" aria-label="Search coins" />
        </label>
        <button id="themeToggle" type="button" aria-label="Toggle dark mode">Toggle Dark Mode</button>
        <span id="healthStatus" class="status-pill">Status: idle</span>
      </div>
    </header>

    <nav class="tabs" aria-label="Sections">
      <button class="tab-btn" data-tab="dashboard" aria-selected="true">Dashboard</button>
      <button class="tab-btn" data-tab="watchlist" aria-selected="false">Watchlist</button>
      <button class="tab-btn" data-tab="alerts" aria-selected="false">Alerts</button>
      <button class="tab-btn" data-tab="settings" aria-selected="false">Settings</button>
    </nav>

    <section id="dashboard" class="panel active" aria-labelledby="Dashboard">
      <div class="inline-row" style="margin-bottom:0.8rem;">
        <label>
          Sort by
          <select id="sortSelect" aria-label="Sort dashboard">
            <option value="name">Name</option>
            <option value="price_desc">Price (high-low)</option>
            <option value="price_asc">Price (low-high)</option>
            <option value="change_desc">24h % (high-low)</option>
            <option value="change_asc">24h % (low-high)</option>
            <option value="updated_desc">Last updated (new-old)</option>
            <option value="updated_asc">Last updated (old-new)</option>
          </select>
        </label>
        <span class="hint">Poll interval applies globally. Sparklines show sampled history.</span>
      </div>
      <div id="cards" class="cards"></div>
    </section>

    <section id="watchlist" class="panel">
      <h2 style="margin-top:0;">Watchlist Management</h2>
      <div class="inline-row">
        <input id="coinInput" type="text" placeholder="CoinGecko id (e.g., bitcoin)" aria-label="CoinGecko ID" />
        <button id="addCoinBtn" type="button">Add Coin</button>
        <a class="link-btn" target="_blank" rel="noopener" href="https://www.coingecko.com/en/coins">Coin list reference</a>
      </div>
      <p class="hint">IDs are case-insensitive. Duplicate IDs are ignored.</p>
      <ul id="watchlistList" class="clean"></ul>
    </section>

    <section id="alerts" class="panel">
      <h2 style="margin-top:0;">Alert Rules & Events</h2>
      <div class="grid-2">
        <div>
          <h3>Create alert rule</h3>
          <div class="inline-row">
            <input id="ruleCoin" type="text" placeholder="coin id" aria-label="Rule coin id" />
            <select id="ruleType" aria-label="Rule type">
              <option value="price_above">Price ABOVE (USD)</option>
              <option value="price_below">Price BELOW (USD)</option>
              <option value="change_above">24h % ABOVE</option>
              <option value="change_below">24h % BELOW</option>
            </select>
            <input id="ruleThreshold" type="number" step="any" placeholder="Threshold" aria-label="Threshold" />
            <button id="addRuleBtn" type="button">Add Rule</button>
          </div>
          <ul id="rulesList" class="clean" style="margin-top:0.7rem;"></ul>
        </div>
        <div>
          <h3>Triggered events</h3>
          <div class="table-wrap">
            <table aria-label="Alert event log">
              <thead>
                <tr><th>Time</th><th>Coin</th><th>Rule</th><th>Value</th></tr>
              </thead>
              <tbody id="eventsTable"></tbody>
            </table>
          </div>
        </div>
      </div>
    </section>

    <section id="settings" class="panel">
      <h2 style="margin-top:0;">Settings & Diagnostics</h2>
      <div class="grid-2">
        <div>
          <h3>Polling</h3>
          <label for="pollSelect">Interval</label>
          <select id="pollSelect">
            <option value="15000">15 seconds</option>
            <option value="30000">30 seconds</option>
            <option value="60000">60 seconds</option>
            <option value="120000">120 seconds</option>
          </select>
          <div style="margin-top:1rem;" class="inline-row">
            <button id="exportBtn" type="button">Export JSON</button>
            <label class="secondary" style="display:inline-flex; align-items:center; gap:0.4rem; padding:0.5rem 0.6rem; border:1px solid var(--border); border-radius:0.5rem; background:var(--surface); cursor:pointer;">
              Import JSON
              <input id="importFile" type="file" accept="application/json" style="display:none;" />
            </label>
            <select id="importMode" aria-label="Import mode">
              <option value="merge">Merge</option>
              <option value="replace">Replace</option>
            </select>
            <button id="clearDataBtn" class="danger" type="button">Clear Local Data</button>
          </div>
        </div>
        <div>
          <h3>Diagnostics</h3>
          <div id="diagnostics" class="diagnostics"></div>
        </div>
      </div>
    </section>
  </div>

  <div id="toastRegion" class="toasts" role="status" aria-live="polite" aria-atomic="false"></div>

  <script>
    (() => {
      "use strict";
      const STORAGE_KEY = "situationMonitor:v1";
      const VERSION = 1;
      const MAX_HISTORY = 120;
      const MAX_EVENTS = 500;

      const defaultState = {
        version: VERSION,
        settings: { theme: "light", pollInterval: 30000 },
        watchlist: ["bitcoin", "ethereum"],
        rules: [],
        events: [],
        history: {}
      };

      let state = loadState();
      let marketData = {};
      let fetchPromise = null;
      let pollTimer = null;
      let lastFetchTs = 0;
      let diagnostics = {
        lastFetchTime: null,
        lastResponseCode: null,
        requestCount: 0,
        currentBackoffDelay: 0,
        lastError: ""
      };

      const elems = {
        body: document.body,
        cards: document.getElementById("cards"),
        watchlistList: document.getElementById("watchlistList"),
        rulesList: document.getElementById("rulesList"),
        eventsTable: document.getElementById("eventsTable"),
        diagnostics: document.getElementById("diagnostics"),
        healthStatus: document.getElementById("healthStatus"),
        searchInput: document.getElementById("searchInput"),
        sortSelect: document.getElementById("sortSelect"),
        coinInput: document.getElementById("coinInput"),
        addCoinBtn: document.getElementById("addCoinBtn"),
        themeToggle: document.getElementById("themeToggle"),
        ruleCoin: document.getElementById("ruleCoin"),
        ruleType: document.getElementById("ruleType"),
        ruleThreshold: document.getElementById("ruleThreshold"),
        addRuleBtn: document.getElementById("addRuleBtn"),
        pollSelect: document.getElementById("pollSelect"),
        exportBtn: document.getElementById("exportBtn"),
        importFile: document.getElementById("importFile"),
        importMode: document.getElementById("importMode"),
        clearDataBtn: document.getElementById("clearDataBtn"),
        toastRegion: document.getElementById("toastRegion")
      };

      init();

      function init() {
        applyTheme();
        bindTabs();
        bindEvents();
        elems.pollSelect.value = String(state.settings.pollInterval);
        renderAll();
        pollOnce(true);
        startPolling();
      }

      function loadState() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return structuredClone(defaultState);
          const parsed = JSON.parse(raw);
          if (parsed.version !== VERSION) return migrateState(parsed);
          return sanitizeState(parsed);
        } catch {
          return structuredClone(defaultState);
        }
      }

      function migrateState(oldState) {
        const merged = { ...defaultState, ...oldState, version: VERSION };
        return sanitizeState(merged);
      }

      function sanitizeState(candidate) {
        const clean = structuredClone(defaultState);
        if (candidate && typeof candidate === "object") {
          clean.settings.theme = candidate.settings?.theme === "dark" ? "dark" : "light";
          const allowedIntervals = [15000, 30000, 60000, 120000];
          clean.settings.pollInterval = allowedIntervals.includes(Number(candidate.settings?.pollInterval))
            ? Number(candidate.settings.pollInterval)
            : 30000;
          clean.watchlist = Array.isArray(candidate.watchlist)
            ? [...new Set(candidate.watchlist.map(v => String(v).trim().toLowerCase()).filter(Boolean))]
            : [];
          clean.rules = Array.isArray(candidate.rules)
            ? candidate.rules.map(r => ({
                id: String(r.id || crypto.randomUUID()),
                coinId: String(r.coinId || "").toLowerCase(),
                type: String(r.type || ""),
                threshold: Number(r.threshold),
                armed: r.armed !== false
              })).filter(r => r.coinId && Number.isFinite(r.threshold) && validRuleType(r.type))
            : [];
          clean.events = Array.isArray(candidate.events)
            ? candidate.events.slice(-MAX_EVENTS).map(e => ({
                t: Number(e.t) || Date.now(),
                coinId: String(e.coinId || ""),
                ruleId: String(e.ruleId || ""),
                ruleType: String(e.ruleType || ""),
                observedValue: Number(e.observedValue)
              }))
            : [];
          clean.history = typeof candidate.history === "object" && candidate.history ? candidate.history : {};
          for (const [coinId, arr] of Object.entries(clean.history)) {
            clean.history[coinId] = Array.isArray(arr)
              ? arr.slice(-MAX_HISTORY).map(x => ({ t: Number(x.t) || Date.now(), price: Number(x.price), change24h: Number(x.change24h) }))
                  .filter(x => Number.isFinite(x.price) && Number.isFinite(x.change24h))
              : [];
          }
        }
        return clean;
      }

      function saveState() {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        } catch (err) {
          showToast(`Failed to save state: ${err.message}`);
        }
      }

      function bindTabs() {
        document.querySelectorAll(".tab-btn").forEach(btn => {
          btn.addEventListener("click", () => {
            const tab = btn.dataset.tab;
            document.querySelectorAll(".tab-btn").forEach(b => b.setAttribute("aria-selected", String(b === btn)));
            document.querySelectorAll("section.panel").forEach(p => p.classList.toggle("active", p.id === tab));
          });
        });
      }

      function bindEvents() {
        elems.searchInput.addEventListener("input", renderDashboard);
        elems.sortSelect.addEventListener("change", renderDashboard);
        elems.themeToggle.addEventListener("click", () => {
          state.settings.theme = state.settings.theme === "dark" ? "light" : "dark";
          applyTheme();
          saveState();
        });

        elems.addCoinBtn.addEventListener("click", () => {
          const id = elems.coinInput.value.trim().toLowerCase();
          if (!id) return;
          if (!state.watchlist.includes(id)) {
            state.watchlist.push(id);
            saveState();
            renderWatchlist();
            renderDashboard();
            pollOnce(true);
          }
          elems.coinInput.value = "";
        });

        elems.addRuleBtn.addEventListener("click", () => {
          const coinId = elems.ruleCoin.value.trim().toLowerCase();
          const type = elems.ruleType.value;
          const threshold = Number(elems.ruleThreshold.value);
          if (!coinId || !validRuleType(type) || !Number.isFinite(threshold)) {
            showToast("Invalid rule input");
            return;
          }
          state.rules.push({ id: crypto.randomUUID(), coinId, type, threshold, armed: true });
          saveState();
          renderRules();
          elems.ruleCoin.value = "";
          elems.ruleThreshold.value = "";
          showToast("Rule added");
        });

        elems.pollSelect.addEventListener("change", () => {
          state.settings.pollInterval = Number(elems.pollSelect.value);
          saveState();
          startPolling();
          showToast(`Polling interval set to ${state.settings.pollInterval / 1000}s`);
        });

        elems.exportBtn.addEventListener("click", exportJson);
        elems.importFile.addEventListener("change", importJson);

        elems.clearDataBtn.addEventListener("click", () => {
          if (!confirm("Clear all persisted Situation Monitor data?")) return;
          state = structuredClone(defaultState);
          marketData = {};
          saveState();
          applyTheme();
          renderAll();
          pollOnce(true);
        });
      }

      function validRuleType(type) {
        return ["price_above", "price_below", "change_above", "change_below"].includes(type);
      }

      async function pollOnce(force = false) {
        if (!state.watchlist.length) {
          updateHealth("idle", "Add coins to start monitoring.");
          renderDiagnostics();
          return;
        }
        const now = Date.now();
        if (!force && now - lastFetchTs < 8000) return;

        try {
          const data = await getMarketData(state.watchlist);
          if (!data || !Array.isArray(data)) return;
          for (const item of data) {
            if (!item?.id) continue;
            marketData[item.id] = item;
            if (!state.history[item.id]) state.history[item.id] = [];
            state.history[item.id].push({
              t: Date.now(),
              price: Number(item.current_price) || 0,
              change24h: Number(item.price_change_percentage_24h) || 0
            });
            if (state.history[item.id].length > MAX_HISTORY) {
              state.history[item.id] = state.history[item.id].slice(-MAX_HISTORY);
            }
          }
          evaluateAlerts();
          saveState();
          renderAll();
          updateHealth("healthy", "Live polling healthy");
          diagnostics.lastError = "";
        } catch (err) {
          diagnostics.lastError = err.message || String(err);
          updateHealth("degraded", diagnostics.lastError);
        }
        renderDiagnostics();
      }

      function startPolling() {
        if (pollTimer) clearInterval(pollTimer);
        pollTimer = setInterval(() => pollOnce(false), state.settings.pollInterval);
      }

      function updateHealth(mode, text) {
        elems.healthStatus.className = `status-pill ${mode}`;
        elems.healthStatus.textContent = `Status: ${mode}${text ? ` • ${text}` : ""}`;
      }

      function getMarketData(coinIds) {
        if (fetchPromise) return fetchPromise;
        fetchPromise = fetchWithBackoff(coinIds)
          .finally(() => { fetchPromise = null; });
        return fetchPromise;
      }

      async function fetchWithBackoff(coinIds) {
        const ids = [...new Set(coinIds.filter(Boolean))].join(",");
        if (!ids) return [];
        const maxAttempts = 5;
        let delay = 1000;

        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
          diagnostics.requestCount += 1;
          diagnostics.currentBackoffDelay = attempt > 1 ? delay : 0;
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), 10000);
          const url = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${encodeURIComponent(ids)}&price_change_percentage=24h`;
          try {
            const res = await fetch(url, { signal: controller.signal, cache: "no-store" });
            clearTimeout(timeout);
            diagnostics.lastResponseCode = res.status;
            diagnostics.lastFetchTime = Date.now();
            if (res.status === 429 || !res.ok) {
              const body = await res.text().catch(() => "");
              throw new Error(`HTTP ${res.status}${body ? `: ${body.slice(0, 120)}` : ""}`);
            }
            lastFetchTs = Date.now();
            return await res.json();
          } catch (err) {
            clearTimeout(timeout);
            diagnostics.lastError = err.name === "AbortError" ? "Request timed out" : (err.message || String(err));
            if (attempt === maxAttempts) throw err;
            const jitter = Math.floor(Math.random() * 400);
            await sleep(delay + jitter);
            delay = Math.min(delay * 2, 20000);
          }
        }
        return [];
      }

      function evaluateAlerts() {
        for (const rule of state.rules) {
          const coin = marketData[rule.coinId];
          if (!coin) continue;
          const value = rule.type.startsWith("price")
            ? Number(coin.current_price)
            : Number(coin.price_change_percentage_24h);
          if (!Number.isFinite(value)) continue;

          const over = value > rule.threshold;
          const under = value < rule.threshold;
          const trigger = (
            (rule.type === "price_above" && over) ||
            (rule.type === "price_below" && under) ||
            (rule.type === "change_above" && over) ||
            (rule.type === "change_below" && under)
          );
          const opposite = (
            (rule.type.endsWith("above") && under) ||
            (rule.type.endsWith("below") && over)
          );

          if (rule.armed && trigger) {
            rule.armed = false;
            const evt = {
              t: Date.now(),
              coinId: rule.coinId,
              ruleId: rule.id,
              ruleType: rule.type,
              observedValue: value
            };
            state.events.push(evt);
            if (state.events.length > MAX_EVENTS) state.events = state.events.slice(-MAX_EVENTS);
            showToast(`${rule.coinId}: ${humanRule(rule)} (observed ${formatRuleValue(rule.type, value)})`);
          } else if (!rule.armed && opposite) {
            rule.armed = true;
          }
        }
      }

      function humanRule(rule) {
        const label = {
          price_above: "price crossed ABOVE",
          price_below: "price crossed BELOW",
          change_above: "24h % crossed ABOVE",
          change_below: "24h % crossed BELOW"
        }[rule.type] || rule.type;
        return `${label} ${formatRuleValue(rule.type, rule.threshold)}`;
      }

      function showToast(message) {
        const toast = document.createElement("div");
        toast.className = "toast";
        toast.innerHTML = `<div>${escapeHtml(message)}</div>`;
        const close = document.createElement("button");
        close.type = "button";
        close.className = "secondary";
        close.textContent = "Dismiss";
        close.addEventListener("click", () => toast.remove());
        toast.appendChild(close);
        elems.toastRegion.appendChild(toast);
        setTimeout(() => toast.remove(), 7000);
      }

      function drawSparkline(canvas, samples) {
        const ctx = canvas.getContext("2d");
        const width = canvas.width;
        const height = canvas.height;
        ctx.clearRect(0, 0, width, height);
        if (!samples || samples.length < 2) {
          ctx.fillStyle = "#999";
          ctx.fillText("n/a", 6, height - 6);
          return;
        }

        const prices = samples.map(s => s.price).filter(Number.isFinite);
        const min = Math.min(...prices);
        const max = Math.max(...prices);
        const range = max - min || 1;

        ctx.lineWidth = 1.8;
        const css = getComputedStyle(document.documentElement);
        ctx.strokeStyle = prices[prices.length - 1] >= prices[0] ? css.getPropertyValue("--success").trim() : css.getPropertyValue("--danger").trim();
        ctx.beginPath();
        prices.forEach((p, i) => {
          const x = (i / (prices.length - 1)) * (width - 4) + 2;
          const y = height - ((p - min) / range) * (height - 6) - 3;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();
      }

      function renderAll() {
        renderWatchlist();
        renderDashboard();
        renderRules();
        renderEvents();
        renderDiagnostics();
      }

      function renderDashboard() {
        const term = elems.searchInput.value.trim().toLowerCase();
        const items = state.watchlist.map(id => {
          const data = marketData[id] || {};
          return {
            id,
            name: data.name || id,
            price: Number(data.current_price),
            change24h: Number(data.price_change_percentage_24h),
            updated: data.last_updated ? new Date(data.last_updated).getTime() : 0
          };
        }).filter(item => !term || item.id.includes(term) || item.name.toLowerCase().includes(term));

        const sort = elems.sortSelect.value;
        items.sort((a, b) => {
          const sorter = {
            name: () => a.name.localeCompare(b.name),
            price_desc: () => (b.price || -Infinity) - (a.price || -Infinity),
            price_asc: () => (a.price || Infinity) - (b.price || Infinity),
            change_desc: () => (b.change24h || -Infinity) - (a.change24h || -Infinity),
            change_asc: () => (a.change24h || Infinity) - (b.change24h || Infinity),
            updated_desc: () => (b.updated || 0) - (a.updated || 0),
            updated_asc: () => (a.updated || 0) - (b.updated || 0)
          };
          return (sorter[sort] || sorter.name)();
        });

        elems.cards.innerHTML = "";
        if (!items.length) {
          elems.cards.innerHTML = `<div class="subtle">No coins match filter.</div>`;
          return;
        }

        for (const item of items) {
          const card = document.createElement("article");
          card.className = "card";
          const signClass = item.change24h >= 0 ? "up" : "down";
          card.innerHTML = `
            <div class="name">
              <span>${escapeHtml(item.name)}</span>
              <span class="subtle">${escapeHtml(item.id)}</span>
            </div>
            <div class="price">${Number.isFinite(item.price) ? formatUsd(item.price) : "--"}</div>
            <div class="${signClass}">${Number.isFinite(item.change24h) ? `${formatPct(item.change24h)} 24h` : "--"}</div>
            <div class="subtle">Last updated: ${item.updated ? new Date(item.updated).toLocaleString() : "n/a"}</div>
            <canvas width="240" height="56" aria-label="sparkline for ${escapeHtml(item.id)}"></canvas>
          `;
          elems.cards.appendChild(card);
          drawSparkline(card.querySelector("canvas"), state.history[item.id] || []);
        }
      }

      function renderWatchlist() {
        elems.watchlistList.innerHTML = "";
        state.watchlist.forEach(id => {
          const li = document.createElement("li");
          li.className = "item";
          li.innerHTML = `<span>${escapeHtml(id)}</span>`;
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "danger";
          btn.textContent = "Remove";
          btn.addEventListener("click", () => {
            state.watchlist = state.watchlist.filter(c => c !== id);
            saveState();
            renderWatchlist();
            renderDashboard();
          });
          li.appendChild(btn);
          elems.watchlistList.appendChild(li);
        });
      }

      function renderRules() {
        elems.rulesList.innerHTML = "";
        state.rules.forEach(rule => {
          const li = document.createElement("li");
          li.className = "item";
          li.innerHTML = `<span>${escapeHtml(rule.coinId)} • ${escapeHtml(humanRule(rule))} • ${rule.armed ? "armed" : "triggered"}</span>`;
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "danger";
          btn.textContent = "Delete";
          btn.addEventListener("click", () => {
            state.rules = state.rules.filter(r => r.id !== rule.id);
            saveState();
            renderRules();
          });
          li.appendChild(btn);
          elems.rulesList.appendChild(li);
        });
      }

      function renderEvents() {
        elems.eventsTable.innerHTML = "";
        state.events.slice().reverse().forEach(evt => {
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${new Date(evt.t).toLocaleString()}</td>
            <td>${escapeHtml(evt.coinId)}</td>
            <td>${escapeHtml(evt.ruleType)}</td>
            <td>${escapeHtml(formatRuleValue(evt.ruleType, evt.observedValue))}</td>
          `;
          elems.eventsTable.appendChild(tr);
        });
      }

      function renderDiagnostics() {
        elems.diagnostics.textContent = [
          `last fetch time: ${diagnostics.lastFetchTime ? new Date(diagnostics.lastFetchTime).toLocaleString() : "n/a"}`,
          `last response code: ${diagnostics.lastResponseCode ?? "n/a"}`,
          `request count this session: ${diagnostics.requestCount}`,
          `current backoff delay(ms): ${diagnostics.currentBackoffDelay}`,
          `last error: ${diagnostics.lastError || "none"}`
        ].join("\n");
      }

      function applyTheme() {
        elems.body.setAttribute("data-theme", state.settings.theme);
      }

      function exportJson() {
        const blob = new Blob([JSON.stringify(state, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `situation-monitor-export-${new Date().toISOString().replace(/[:.]/g, "-")}.json`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }

      async function importJson(event) {
        const file = event.target.files?.[0];
        if (!file) return;
        try {
          const raw = await file.text();
          const data = JSON.parse(raw);
          const incoming = sanitizeState(data);
          if (elems.importMode.value === "replace") {
            state = incoming;
          } else {
            state = mergeStates(state, incoming);
          }
          saveState();
          applyTheme();
          renderAll();
          pollOnce(true);
          showToast("Import successful");
        } catch (err) {
          showToast(`Import failed: ${err.message}`);
        } finally {
          event.target.value = "";
        }
      }

      function mergeStates(base, incoming) {
        const merged = sanitizeState({
          ...base,
          ...incoming,
          settings: { ...base.settings, ...incoming.settings },
          watchlist: [...new Set([...(base.watchlist || []), ...(incoming.watchlist || [])])],
          rules: [...(base.rules || []), ...(incoming.rules || [])],
          events: [...(base.events || []), ...(incoming.events || [])].slice(-MAX_EVENTS),
          history: { ...(base.history || {}), ...(incoming.history || {}) }
        });
        return merged;
      }

      function formatUsd(value) {
        return new Intl.NumberFormat("en-US", { style: "currency", currency: "USD", maximumFractionDigits: value < 1 ? 6 : 2 }).format(value);
      }

      function formatPct(value) {
        return `${value >= 0 ? "+" : ""}${value.toFixed(2)}%`;
      }

      function formatRuleValue(type, value) {
        return type.startsWith("price") ? formatUsd(value) : formatPct(value);
      }

      function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      function escapeHtml(str) {
        return String(str)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }
    })();
  </script>
</body>
</html>
